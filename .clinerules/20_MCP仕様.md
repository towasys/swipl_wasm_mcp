# モデルコンテキストプロトコル（MCP）TypeScript SDK 使用ガイド
## 1. モデルコンテキストプロトコル（MCP）の紹介 {#モデルコンテキストプロトコル-mcpの紹介}
モデルコンテキストプロトコル（MCP）は、大規模言語モデル（LLM）の機能を強化するための基盤技術として機能し、アプリケーションが関連する文脈情報を供給するための標準化された方法を提供します。

## 2. MCP TypeScript SDK の始め方 {#mcp-typescript-sdkの始め方}
モデルコンテキストプロトコルの公式TypeScriptソフトウェア開発キット（SDK）は、開発者にMCPサーバーとクライアントの両方を構築するための包括的なツールセットを提供します^11^。このSDKはMCP仕様を完全に実装し、それを使用して構築されたアプリケーションがプロトコルに準拠し、他のMCP対応システムとシームレスに相互作用できることを保証します^11^。TypeScript SDKを使用することで、開発者はLLMがデータにアクセスし、関数を実行し、事前定義された相互作用パターンに従う方法を定義するためにその機能を活用し、MCP統合の作成プロセスを大幅に簡素化できます^11^。SDKは、コマンドラインツールや直接統合のための標準入出力（stdio）などの標準的な伝送メカニズム、およびリモートサーバーやWebサービスを構築するためのHTTPとサーバー送信イベント（SSE）をサポートしています^11^。この柔軟性により、開発者は特定のユースケースと展開環境に基づいて最も適切な通信方法を選択できます。
MCP TypeScript SDKの使用を開始するには、TypeScriptとNode.jsプロジェクトの標準的なインストール手順として、Node Package Managerであるnpmを使用します^11^。開発者は、ターミナルまたはコマンドプロンプトでnpm install @modelcontextprotocol/sdkコマンドを実行してSDKをインストールできます^11^。このコマンドは、必要なパッケージとその依存関係をプロジェクトのnode_modulesディレクトリにダウンロードしてインストールします。このコマンドを実行する前に、開発システムにNode.jsとnpmが既にインストールされていることを確認することが重要です^11^。
SDKをインストールする前に、基本的なTypeScriptプロジェクトをセットアップすることをお勧めします。これには通常、新しいプロジェクトディレクトリの作成^14^、プロジェクトの依存関係とスクリプトを管理するためのpackage.jsonファイルの初期化^14^、およびTypeScriptコンパイラオプションを指定するためのtsconfig.jsonファイルの設定^14^が含まれます。これらのステップは、TypeScript開発ワークフローの基本であり、プロジェクトがMCP TypeScript SDKを適切に使用するように設定されていることを確認します。この標準的なプロジェクトセットアップアプローチにより、TypeScriptエコシステムに精通した開発者は、既存または新しいプロジェクトにMCP SDKを簡単に統合できます。

## 3. TypeScript SDKの核となる概念 {#typescript-sdk-core-concepts}
MCP TypeScript SDKは、4つの基本的な概念に基づいて構築されています：サーバー、リソース、ツール、プロンプト ^11^。これらの核となる概念を理解することは、LLMとの強力な統合を作成するためにSDKを効果的に利用する上で重要です。
**サーバー**は、McpServerクラスによって表現され、MCPプロトコル ^11^を実装するための中心的なコンポーネントです。サーバーはオーケストレーターとして機能し、MCPクライアントとの接続を管理し、プロトコル仕様に準拠していることを確認し、サーバーと接続されたクライアント間でメッセージをルーティングします ^11^。McpServerをインスタンス化した際、名前とバージョンで初期化され、これにより異なるサーバー実装の識別と管理が容易になります ^11^。このクラスはMCPプロトコルの基本的な複雑さを処理し、開発者がサーバーの特定の機能を定義することに集中できるようにします。
**リソース**は、MCPサーバーがLLMアプリケーションにデータを公開するためのメカニズムを提供します ^11^。これらはREST APIのGETエンドポイントに似た機能を持ち、クライアントがサーバー上で重要な計算や副作用を発生させることなく情報を取得できるようにします ^11^。リソースの主な目的は、LLMのコンテキストに関連データをロードし、より情報に基づいた応答を生成できるようにすることです ^11^。リソースは静的で、すべてのリクエストに対して同じデータを提供することもあれば、動的で、リクエストURIで提供されたパラメータに基づいてResourceTemplateを使用してデータを生成することもできます ^12^。この柔軟性により、単純な設定からユーザー固有の情報まで、幅広いデータを公開することができます。
**ツール**は、LLMがMCPサーバーを通じてアクションを実行できるようにします ^11^。リソースとは異なり、ツールは計算を実行し、REST APIのPOSTエンドポイントに似た副作用を持つように設計されています ^11^。開発者は、ツール名、入力パラメータのオプションスキーマ（多くの場合、型検証にZodのようなライブラリを使用）、およびツールのロジックを実装する非同期関数を定義します ^12^。LLMがツールの使用を決定した場合、必要なパラメータを提供し、定義されたスキーマに対して検証した後にツールの関数が実行されます ^11^。このメカニズムにより、LLMは外部システムと対話し、計算を実行したり、制御された構造化された方法でデータを操作したりすることができます。
**プロンプト**は、LLMがMCPサーバーとどのように対話するかを導く再利用可能なテンプレートです ^11^。これらは特定の対話パターンを定義し、動的なコンテンツのためのプレースホルダーを含めることができます ^11^。プロンプトを使用することで、開発者は一般的なタスクを標準化し、LLMが予測可能で効果的な方法でサーバーと対話することを確保できます ^11^。プロンプトには通常、LLMのための指示や例が含まれており、利用可能なリソースとツールを使用して特定の目標を達成する方法を理解するのに役立ちます。

| **概念** | **説明** | **アナロジー** |
|---------|----------|----------------|
| サーバー | MCPの接続、プロトコル準拠、メッセージルーティングを管理する中心的なコンポーネント。 | Webサーバー |
| リソース | LLMアプリケーションにデータを公開するメカニズム。読み取り専用で、副作用がないはずです。 | REST APIのGETエンドポイント |
| ツール | サーバーを通じてLLMがアクションを実行できるようにする。計算を実行し、副作用を持つ可能性があります。 | REST APIのPOSTエンドポイント |
| プロンプト | LLMとMCPサーバー間の対話パターンを定義する再利用可能なテンプレート。動的なコンテンツのためのプレースホルダーを含めることができます。 | 事前定義されたAPIリクエスト |

## 4. 基本的な使用方法と例 {#basic-usage-and-examples}
MCP TypeScript SDKの基本的な使用方法を説明するために、単純な「Hello, World!」MCPサーバーを考えてみましょう。これには、指定された名前とバージョンでMcpServerをインスタンス化することが含まれます：

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new McpServer({
  name: "HelloWorldServer",
  version: "1.0.0",
});

const transport = new StdioServerTransport();
await server.connect(transport);
console.log("Hello, World! MCP Server is running.");
```

この基本的な例では、「HelloWorldServer」という名前のMCPサーバーをバージョン「1.0.0」で作成し、標準入出力トランスポートに接続して、MCPクライアントとの通信準備が整います。

リソース作成を示すために、JSONとして設定オブジェクトを提供する静的リソースを作成できます：

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new McpServer({
  name: "ConfigServer",
  version: "1.0.0",
});

server.resource("config", "config://app", async (uri) => ({
  contents: JSON.stringify({ key: "value" }),
}));

const transport = new StdioServerTransport();
await server.connect(transport);
console.log("Config Server is running and serving configuration.");
```

ここでは、「config」という名前のリソースが定義され、「config://app」というURIでアクセス可能です。クライアントがこのリソースをリクエストすると、サーバーは設定オブジェクトを表すJSON文字列を応答します。

ツール作成を示すために、2つの数字を加算する簡単なツールを定義できます：

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const server = new McpServer({
  name: "CalculatorServer",
  version: "1.0.0",
});

server.tool(
  "add",
  {
    a: z.number(),
    b: z.number(),
  },
  async ({ a, b }) => ({
    content: `Sum: ${a + b}`,
  })
);

const transport = new StdioServerTransport();
await server.connect(transport);
console.log("Calculator Server is running with an 'add' tool.");
```

この例では、「add」という名前のツールを定義し、2つの数値パラメータaとbを取り、それらの合計をテキストコンテンツとして返します。入力パラメータはZodを使用して型検証のために定義されています。

最後に、プロンプトを定義して使用する方法を示すために、簡単なプロンプトテンプレートを作成できます：

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const server = new McpServer({
  name: "GreetingServer",
  version: "1.0.0",
});

server.prompt(
  "greet",
  {
    name: z.string(),
  },
  ({ name }) => ({
    messages: [
      {
        role: "user",
        content: { type: "text", text: `Please say hello to ${name}.` },
      },
    ],
  })
);

const transport = new StdioServerTransport();
await server.connect(transport);
console.log("Greeting Server is running with a 'greet' prompt.");
```

この例では、「greet」という名前のプロンプトを定義し、名前パラメータを取り、LLMに提供された名前に挨拶するよう求めるユーザーメッセージを生成します。これらの基本的な例は、MCP TypeScript SDKの核となる概念を作成し利用する方法を理解するための基礎を提供します。


## 5. 高度な使用法と機能 {#advanced-usage-and-features}
MCP TypeScript SDKは、開発者がより高度な統合を構築できるようにするいくつかの高度な機能を提供します。重要な側面の一つは、MCPサーバーとクライアント間の通信方法の柔軟性を可能にする異なる伝送メカニズムのサポートです^11^。**stdio**伝送は、プロセスの標準入出力ストリームを通じて通信が行われるコマンドラインツールや直接的な統合に特に有用です^11^。例えば、コマンドラインアプリケーションとして実装されたMCPサーバーは、標準入力からLLMからのリクエストを受け取り、標準出力から応答を送り返すことができます。一方、**HTTP with SSE**は、リモートサーバーやウェブサービスの構築に適しています^11^。このモードでは、MCPサーバーはHTTPエンドポイントを公開し、サーバー送信イベントを使用してクライアントにメッセージをプッシュし、ウェブ上でのリアルタイム通信を可能にします。SDKは、これらの異なる通信方法の実装を容易にするために、StdioServerTransportやSSEServerTransportなどの特定の伝送クラスを提供しています。
基本的なリソースとツールを超えて、SDKはより複雑な機能の作成を可能にします。実用的な例として、MCPサーバーとSQLiteデータベースの統合があります^11^。これには、データベーススキーマをLLMに取得して公開するリソースを定義し、データ構造を理解するために必要なコンテキストを提供することが含まれます^11^。さらに、LLMが提供するSQLクエリを実行して結果を返すツールを実装することもできます^11^。これにより、LLMは自然言語でデータベースと対話し、必要な特定の情報を取得することができます。同様に、MCPサーバーは外部APIからデータを取得するように設計することもできます^12^。これには、APIエンドポイントに関連するパラメータを受け取り、APIにHTTPリクエストを行い、LLMが理解して利用できる形式で応答をフォーマットするツールの作成が含まれる可能性があります。
SDKはまた、これらのサーバーと対話できるMCPクライアントを書くために必要なコンポーネントも提供しています^11^。Clientクラスは、MCPクライアントを作成するための基盤として機能します^11^。サーバーに接続するために、クライアントはサーバーの伝送メカニズムと互換性のある伝送を使用する必要があります。例えば、stdioを使用するサーバーにはStdioClientTransport、HTTP with SSEを使用するサーバーにはSSEClientTransportを使用します^11^。接続が確立されると、クライアントはClientクラスによって提供されるメソッドを使用してサーバーの機能と対話できます。これには、client.listPrompts()を使用して利用可能なプロンプトをリストアップし、client.getPrompt()を使用して引数付きの特定のプロンプトを取得し、client.listResources()を使用して利用可能なリソースをリストアップし、client.readResource()を使用してリソースのコンテンツを読み取り、client.callTool()を使用して指定された引数でツールを呼び出すことが含まます^11^。
サーバーの機能とライフサイクルイベントを処理する方法を理解することは、堅牢なMCPアプリケーションを構築する上で重要です。MCPサーバーは、提供するツール、リソース、プロンプトなどの機能を宣言します^11^。クライアントはこれらの機能をクエリして、利用可能な機能を理解できます^11^。クライアントとサーバー間の通信は、プロトコルバージョンと機能がネゴシエーションされる初期化フェーズから始まり、メッセージが交換される運用フェーズを経て、最終的に接続が適切に終了するシャットダウンフェーズで終了します^16^。SDKは、このライフサイクルを管理し、クライアントとサーバーがネゴシエーションされた機能に従うことを確実にするためのメカニズムを提供しています。

## 6. APIリファレンス概要 {#api-reference-overview}
MCP TypeScript SDKの包括的な理解には、公式APIドキュメントのナビゲーションが不可欠です。SDKのAPIリファレンスの主要なリソースは、modelcontextprotocol/typescript-sdkにある公式GitHubリポジトリです^11^。このリポジトリには、ソースコード、例、およびSDKの機能と機能を調査するための優れた出発点となる詳細なREADMEファイルが含まれています^11^。READMEの目次は、SDKのさまざまな側面（インストール、クイックスタート、コアコンセプト、サーバーの実行、例、高度な使用法など）の構造化された概要を提供します^11^。
GitHubリポジトリに加えて、modelcontextprotocol.ioウェブサイトは、ガイド、チュートリアル、プロトコル自体の仕様を含む、すべてのMCP関連のドキュメントの中央ハブとして機能します^1^。このウェブサイトは、MCPとそのSDK（異なるプログラミング言語で）に関する包括的な情報にアクセスするためのユーザーフレンドリーなインターフェースを提供します^1^。プロトコルの技術的詳細を深く掘り下げるために、spec.modelcontextprotocol.ioでホストされているMCP仕様は、プロトコル要件の権威ある定義を提供します^17^。
TypeScript SDK内では、McpServerクラスがMCPサーバーの構築に使用され、ClientクラスがMCPクライアントの作成に使用されます^11^。ResourceTemplateクラスは動的リソースを定義するのに役立ちます^12^。主要な機能には、サーバーの機能を定義するためのresource()、tool()、prompt()、および接続を確立するためのconnect()が含まれます^11^。クライアント側では、listPrompts()、getPrompt()、listResources()、readResource()、およびcallTool()などの機能が、MCPサーバーとの対話に不可欠です^11^。SDKはまた、異なる通信方法を処理するためのStdioServerTransport、SSEServerTransport、StdioClientTransport、SSEClientTransportなどの伝送固有のクラスを提供しています^11^。これらの主要コンポーネントのドキュメントを探索することで、開発者はMCP TypeScript SDKをプロジェクトでどのように活用するかについて徹底的な理解を得ることができます。

## 7. 一般的な使用例と実践的な応用 {#common-use-cases-and-practical-applications}
Model Context Protocol TypeScript SDKは、LLMと外部システム間のシームレスな統合を可能にすることで、幅広い実用的な応用を可能にします。魅力的な使用例の一つは、**コードレビューボット**の開発です^12^。このシナリオでは、コードファイルはMCPサーバーを通じてリソースとして公開されます。次に、レビューコードプロンプトを定義し、LLMに提供されたコードを分析して改善を提案するよう指示します。これにより、開発者はコード品質の向上のために、開発ワークフロー内で直接LLMの推論能力を活用できます^12^。
もう一つの重要な応用は、**データダッシュボード**の作成です^12^。ここでは、データセットをリソースとして提供し、LLMに構造化された情報へのアクセスを提供します。さらに、これらのデータセットをクエリおよび分析するためのツールを追加し、LLMが自然言語コマンドに基づいて洞察や視覚化を生成できるようにします。これにより、データ分析が民主化され、専門的なデータサイエンスのスキルを持たないユーザーでも価値ある情報を抽出できるようになります^12^。
SDKはまた、**スマートチャットボット**の構築に非常に有用です^10^。一般的なユーザークエリ用のプロンプトと、チャットボットに顧客データやナレッジベースへのアクセスを提供するリソースを使用することで、LLMはよりパーソナライズされた関連性の高い応答を提供できます^12^。さらに、アクション（例：注文の作成や予約のスケジュール）を実行できるようにするためのツールを統合することで、より汎用的で役立つアシスタントにすることができます^12^。
MCPの汎用性は、様々な人気のあるサービスとの統合にまで及びます^18^。例えば、LLMを**GitHub**と接続して、リポジトリ管理、課題追跡、自然言語コマンドによるコード操作を可能にすることができます^6^。**Slack**との統合により、LLMはメッセージの送信、チャンネルの管理、または会話からの情報の取得を可能にします^6^。同様に、**Google Drive**への接続により、LLMはそこに保存されているデータに基づいて情報の取得やコンテンツ生成を行うことができます^6^。MCPはまた、**PostgreSQL**や**SQLite**などのデータベースとの対話を促進し、LLMがユーザーリクエストに基づいてデータをクエリおよび取得できるようにします^6^。これらの統合は、LLMと既存のツールやデータソースの膨大なエコシステムの間のギャップを埋めるMCPの力を示しています。
| **使用例**                 | **説明**                                                                                                                                        | **主要なSDK機能の使用** |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------|-------------------------|
| コードレビューボット        | コードファイルをLLMに公開し、フィードバックと改善の提案をLLMに提供するためのプロンプトを使用します。                        | リソース、プロンプト        |
| データダッシュボード        | データセットをLLMに提供し、データのクエリと分析のためのツールを提供し、自然言語ベースの洞察を可能にします。                | リソース、ツール          |
| スマートチャットボット      | 一般的なクエリ用のプロンプト、顧客データ用のリソース、アクションを実行するためのツールを統合し、チャットボットの機能を強化します。| プロンプト、リソース、ツール |
| GitHub統合                 | リポジトリ管理、課題追跡、自然言語によるコード操作などのタスクのために、LLMをGitHubに接続します。                        | リソース、ツール          |
| Slack統合                   | メッセージング、チャンネル管理、情報の取得のために、LLMがSlackと対話できるようにします。                                        | リソース、ツール          |
| Google Drive統合           | LLMにGoogle Driveに保存されているファイルとドキュメントへのアクセスを提供し、情報の取得とコンテンツ生成を可能にします。        | リソース、ツール          |
| データベース統合           | LLMがPostgreSQLやSQLiteなどのデータベースから自然言語コマンドを使用してデータをクエリおよび取得できるようにします。        | リソース、ツール          |

## 8. TypeScript SDKを使用した開発のベストプラクティス {#best-practices-for-developing-with-the-typescript-sdk}
MCP TypeScript SDKを使用した開発には、安全で信頼性の高い、保守可能なアプリケーションを作成するために、いくつかのベストプラクティスに注意を払う必要があります。LLMと外部システムを統合する際、**セキュリティ**は最も重要な懸念事項です。開発者は、ユーザーがデータのアクセスと操作に関するデータ共有やLLMが行うアクションを明示的に理解し、承認することを確実にし、ユーザーの同意と制御を優先すべきです^16^。ユーザーデータを保護するための適切なアクセス制御の実装も重要です^16^。ツールが任意のコード実行を表す可能性があるため、開発者はツールの使用を承認する前に、ユーザーがそのツールの内容を認識していることを確認する必要があります^16^。同様に、LLMのサンプリング要求は明示的なユーザー承認を必要とすべきです^16^。
**エラー処理とロギング**は、MCPアプリケーションの堅牢性にとって不可欠です^13^。適切なエラー処理メカニズムを実装し、意味のあるエラーメッセージを提供することで、ユーザー体験を向上させ、デバッグを簡素化できます^13^。実行の流れを追跡し、イベントを記録し、潜在的な問題をキャプチャするためのロギングの利用も、MCPサーバーとクライアントの監視とトラブルシューティングにとって重要です^16^。**コードの組織化と保守性**の良いプラクティスを遵守することは、長期的なプロジェクトの成功にとって重要です^12^。コンテキスト管理のロジックをLLMとの対話から分離することで、よりクリーンでモジュール化されたコードにつながります^12^。リソース、ツール、プロンプト用の再利用可能なコンポーネントを構築することで、開発時間を節約し、アプリケーション全体での一貫性を向上させることができます^12^。明確な命名規則の使用、十分に文書化されたコードの記述、コーディングスタイルガイドラインの遵守など、一般的なTypeScriptのベストプラクティスに従うことも、コードベースの保守性に貢献します^13^。
効果的な**テストとデバッグ戦略**は、MCP実装の信頼性を確保するために必要です。MCPインスペクターツールは、MCPサーバーのテスト用にインタラクティブなデバッグインターフェースを提供し、開発者がリクエストと応答を検査できるようにします^1^。さらに、Claude Desktop Developer Toolsを活用することで、Claude環境内でのMCPクライアントとサーバー間の通信を理解するのに役立ちます^20^。MCPアプリケーションの異なるコンポーネントのユニットテストと統合テストを書くことも強く推奨され、開発サイクルの早い段階で潜在的な問題を発見できます。

## 9. コミュニティとサポートリソース {#community-and-support-resources}
MCP TypeScript SDKを使用する開発者にとって、いくつかの価値あるコミュニティとサポートリソースが利用可能です。公式GitHubリポジトリ（modelcontextprotocol/typescript-sdk）は、SDKのソースとしてだけでなく、コミュニティエンゲージメントのプラットフォームとしても機能します^11^。"Issues"タブは、バグを報告したり、新機能を提案したり、特定の問題について助けを求めたりするために使用できます^21^。"Discussions"タブは、よりオープンな会話のためのフォーラムを提供し、開発者がSDKとMCPプロトコルの使用に関する経験を共有し、質問をし、ベストプラクティスについて議論できるようにします^1^。
公式ドキュメンテーションウェブサイト、modelcontextprotocol.ioは、プロトコルとSDKを詳細に理解するための包括的なガイド、チュートリアル、APIリファレンスを提供します^1^。spec.modelcontextprotocol.ioで利用可能なMCP仕様は、プロトコルの決定的な技術的詳細を提供し、高度なユーザーやカスタム統合を実装しようとする人々にとって有用なリソースとなり得ます^21^。
公式リソースの他にも、AIとLLM開発に特化した様々なオンラインコミュニティやフォーラムが、Model Context Protocolに関連する議論を開催している可能性があります。これらのコミュニティに参加することで、追加の視点、一般的な問題に対する解決策、この分野で働く他の開発者とつながる機会を得ることができます^22^。これらのリソースに積極的に参加することで、開発者はMCPエコシステムの最新の動向について情報を得、革新的なAIアプリケーションを構築するために必要なサポートを得ることができます。

## 10. 結論 {#conclusion}
Model Context Protocol TypeScript SDKは、大規模言語モデルと外部データソースやツールを統合するための堅牢で標準化されたフレームワークを提供します。その主な利点には、様々なリソースへのLLMの接続プロセスを簡素化する標準化された統合、再利用可能なコンポーネントの作成を可能にするモジュール性、ユーザーの同意と制御されたアクセスを通じて強化されたセキュリティ、異なるアプリケーション間での資源、ツール、プロンプトの再利用性、そして時間とともに進化する可能性のある複雑なAIシステムの構築を可能にするスケーラビリティが含まれます^12^。TypeScript開発者にとって、SDKは高度なAI機能をフルスタックアプリケーションに組み込むための自然で効率的な方法を提供します^12^。
将来を見据えると、Model Context ProtocolはAIエコシステム内で大きな可能性を示しています^5^。様々なプラットフォームやツールでの成長する採用は、MCPがAIエージェント統合のデフォルトプロトコルになる可能性があることを示唆しており、これはREST APIがウェブサービスの標準となったのと同様です^8^。プロトコルが進化し、新機能が追加され続けるにつれて、MCPは次世代のAIアプリケーションを形作る上で重要な役割を果たし、人間と人工知能の間のよりシームレスで安全で、コンテキストを認識した相互作用を可能にすることが期待されます。